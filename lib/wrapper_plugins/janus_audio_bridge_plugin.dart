part of janus_client;

class JanusAudioBridgePlugin extends JanusPlugin {
  JanusAudioBridgePlugin({handleId, context, transport, session})
      : super(context: context, handleId: handleId, plugin: JanusPlugins.AUDIO_BRIDGE, session: session, transport: transport);

  /// Creates a new audio bridge room and returns its descriptor.
  ///
  /// Parameters:
  /// - [roomId]: Optional numeric identifier; generated by Janus when omitted.
  /// - [permanent]: When `true`, the room is persisted to the plugin config.
  /// - [description]: Human-friendly room name.
  /// - [secret]: Password required to edit or destroy the room.
  /// - [pin]: Password required for participants to join.
  /// - [isPrivate]: Hides the room from list queries when `true`.
  /// - [allowed]: Optional list of tokens authorized to join the room.
  /// - [samplingRate]: Audio sampling rate (defaults to 16000 Hz).
  /// - [spatialAudio]: Enables positional audio for participants.
  /// - [audioLevelExt]: Requests negotiation of the audio-level RTP extension.
  /// - [audioLevelEvent]: Emits level events to other participants when `true`.
  /// - [audioActivePackets]: Packet window used for activity detection.
  /// - [audioLevelAverage]: Audio-level threshold (0 loud â€“ 127 muted).
  /// - [defaultPreBuffering]: Number of packets to buffer before decode.
  /// - [defaultExpectedLoss]: Expected packet loss percentage for FEC.
  /// - [defaultBitRate]: Opus bitrate override in bits per second.
  /// - [record]: Records the mixed room audio when enabled.
  /// - [recordFile]: Destination file name for recordings.
  /// - [recordDir]: Directory used as base for [recordFile].
  /// - [allowRtpParticipants]: Allows plain RTP participants when `true`.
  /// - [groups]: Named participant groups used for forwarding.
  Future<AudioRoomCreatedResponse> createRoom(dynamic roomId,
      {bool permanent = true,
      String? description,
      String? secret,
      String? pin,
      int? defaultBitRate,
      int? defaultExpectedLoss,
      bool? isPrivate,
      bool? audioLevelExt,
      bool? audioLevelEvent,
      int? audioActivePackets,
      int? audioLevelAverage,
      List<String>? allowed,
      bool? record,
      String? recordFile,
      String? recordDir,
      int? defaultPreBuffering,
      String? allowRtpParticipants,
      int? samplingRate,
      List<String>? groups,
      bool? spatialAudio}) async {
    var payload = {
      "request": "create",
      "room": roomId,
      "permanent": permanent,
      "description": description,
      "secret": secret,
      "pin": pin,
      "default_bitrate": defaultBitRate,
      "default_expectedloss": defaultExpectedLoss,
      "is_private": isPrivate,
      "allowed": allowed,
      "sampling_rate": samplingRate,
      "spatial_audio": spatialAudio,
      "audiolevel_ext": audioLevelExt,
      "audiolevel_event": audioLevelEvent,
      "audio_active_packets": audioActivePackets,
      "audio_level_average": audioLevelAverage,
      "default_prebuffering": defaultPreBuffering,
      "record": record,
      "record_file": recordFile,
      "record_dir": recordDir,
      "allow_rtp_participants": allowRtpParticipants,
      "groups": groups
    }..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return AudioRoomCreatedResponse.fromJson(response.plugindata?.data);
  }

  /// Updates mutable metadata for an existing audio bridge room.
  ///
  /// Parameters:
  /// - [roomId]: Numeric identifier of the target room.
  /// - [secret]: Current room secret when one is configured.
  /// - [newDescription]: Updated display name.
  /// - [newSecret]: New admin secret for destructive operations.
  /// - [newPin]: New pin required for participants to join.
  /// - [newIsPrivate]: Hides the room from list queries when `true`.
  /// - [permanent]: Persists changes back to the plugin configuration.
  Future<dynamic> editRoom(dynamic roomId, {String? secret, String? newDescription, String? newSecret, String? newPin, bool? newIsPrivate, bool? permanent}) async {
    var payload = {
      "request": "edit",
      "room": roomId,
      "secret": secret,
      "new_description": newDescription,
      "new_secret": newSecret,
      "new_pin": newPin,
      "new_is_private": newIsPrivate,
      "permanent": permanent
    }..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return AudioRoomCreatedResponse.fromJson(response.plugindata?.data);
  }

  /// Joins an audio bridge room and optionally overrides per-participant settings.
  ///
  /// Parameters:
  /// - [roomId]: Identifier of the destination room.
  /// - [id]: Optional participant ID; generated by Janus when omitted.
  /// - [group]: Participant group used for forwarding features.
  /// - [pin]: Room pin when configured.
  /// - [display]: Display name reported to other participants.
  /// - [token]: Invitation token when ACL is enforced.
  /// - [muted]: Starts the participant muted when `true`.
  /// - [codec]: Preferred codec (`opus`, `pcma`, or `pcmu`).
  /// - [preBuffer]: Local pre-buffer size prior to decoding.
  /// - [bitrate]: Opus bitrate override in bits per second.
  /// - [quality]: Opus complexity (0-10).
  /// - [expectedLoss]: Expected packet loss percentage for FEC.
  /// - [volume]: Playback gain percentage (100 = unchanged).
  /// - [spatialPosition]: Stereo pan when spatial audio is enabled (0 left, 50 center, 100 right).
  /// - [secret]: Room management password granting admin privileges.
  /// - [audioLevelAverage]: Overrides the room threshold for this user.
  /// - [audioActivePackets]: Overrides room packet window for activity detection.
  /// - [record]: Records this participant's contribution when `true`.
  /// - [filename]: Base filename (without suffix) for participant recordings.
  Future<void> joinRoom(dynamic roomId,
      {dynamic id,
      String? group,
      String? pin,
      int? expectedLoss,
      String? display,
      String? token,
      bool? muted,
      String? codec,
      int? preBuffer,
      int? quality,
      int? volume,
      int? spatialPosition,
      String? secret,
      String? audioLevelAverage,
      String? audioActivePackets,
      bool? record,
      String? filename}) async {
    Map<String, dynamic> payload = {
      "request": "join",
      "room": roomId,
      "id": id,
      "group": group,
      "pin": pin,
      "display": display,
      "token": token,
      "muted": muted,
      "codec": codec,
      "prebuffer": preBuffer,
      "expected_loss": expectedLoss,
      "quality": quality,
      "volume": volume,
      "spatial_position": spatialPosition,
      "secret": secret,
      "audio_level_average": audioLevelAverage,
      "audioActivePackets": audioActivePackets,
      "record": record,
      "filename": filename
    }..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
  }

  /// Reconfigures a participant already attached to the audio bridge.
  ///
  /// Parameters:
  /// - [muted]: Toggles participant mute state.
  /// - [display]: Updates the participant display name.
  /// - [preBuffer]: Adjusts pre-buffer packets before decode.
  /// - [bitrate]: Overrides Opus bitrate in bits per second.
  /// - [quality]: Adjusts Opus complexity (0-10).
  /// - [expectedLoss]: Expected packet loss percentage for FEC.
  /// - [volume]: Playback gain percentage (100 = unchanged).
  /// - [spatialPosition]: Stereo pan when spatial audio is enabled.
  /// - [record]: Records this participant's RTP stream when `true`.
  /// - [filename]: Basename for the per-participant recording.
  /// - [group]: Updates forwarding group membership.
  /// - [offer]: Custom SDP offer; audio send/recv is negotiated when omitted.
  Future<void> configure(
      {bool? muted,
      int? bitrate,
      String? display,
      int? preBuffer,
      int? quality,
      int? volume,
      int? spatialPosition,
      bool? record,
      String? filename,
      String? group,
      RTCSessionDescription? offer}) async {
    var payload = {
      "request": "configure",
      "muted": muted,
      "display": display,
      "bitrate": bitrate,
      "prebuffer": preBuffer,
      "quality": quality,
      "volume": volume,
      "spatial_position": spatialPosition,
      "record": record,
      "filename": filename,
      "group": group
    }..removeWhere((key, value) => value == null);
    if (offer == null) {
      offer = await this.createOffer(videoRecv: false, audioRecv: true);
    }
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload, jsep: offer));
    JanusError.throwErrorFromEvent(response);
  }

  /// Mutes or unmutes a participant when the caller holds the room secret.
  ///
  /// Parameters:
  /// - [roomId]: Target room identifier.
  /// - [participantId]: Numeric participant identifier.
  /// - [mute]: `true` to mute, `false` to unmute.
  /// - [secret]: Room admin secret when configured.
  Future<dynamic> muteParticipant(dynamic roomId, int participantId, bool mute, {String? secret}) async {
    var payload = {"request": mute ? 'mute' : 'unmute', "secret": secret, "room": roomId, "id": participantId}..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return response.plugindata?.data;
  }

  /// Stops a previously created RTP forwarder for the audio bridge room.
  ///
  /// Parameters:
  /// - [roomId]: Room identifier hosting the forwarder.
  /// - [streamId]: Forwarder identifier to terminate.
  Future<RtpForwardStopped> stopRtpForward(dynamic roomId, int streamId) async {
    var payload = {"request": "stop_rtp_forward", "room": roomId, "stream_id": streamId};
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return RtpForwardStopped.fromJson(response.plugindata?.data);
  }

  /// Removes a participant from the room when the admin secret is provided.
  ///
  /// Parameters:
  /// - [roomId]: Target room identifier.
  /// - [participantId]: Participant to remove.
  /// - [secret]: Room admin secret when configured.
  Future<dynamic> kickParticipant(dynamic roomId, int participantId, {String? secret}) async {
    var payload = {"request": "kick", "secret": secret, "room": roomId, "id": participantId}..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return response.plugindata?.data;
  }

  /// Starts forwarding room audio to an external RTP endpoint.
  ///
  /// Parameters:
  /// - [roomId]: Room whose mix should be forwarded.
  /// - [host]: Destination host for the RTP stream.
  /// - [port]: Destination port.
  /// - [group]: Participant group to forward (forwards mix when omitted).
  /// - [adminKey]: Admin key required when configured.
  /// - [ssrc]: Overrides the SSRC used for forwarding.
  /// - [codec]: Codec hint (`opus`, `pcma`, or `pcmu`).
  /// - [ptype]: Optional payload type to advertise.
  /// - [srtpSuite]: SRTP authentication tag length (32 or 80).
  /// - [alwaysOn]: Keeps forwarding even when the room is empty.
  /// - [hostFamily]: `ipv4` or `ipv6` when resolving [host].
  /// - [srtpCrypto]: Base64-encoded SRTP key material when SRTP is desired.
  Future<RtpForwarderCreated> rtpForward(dynamic roomId, String host, int port,
      {String? group, String? adminKey, String? ssrc, String? codec, String? ptype, int? srtpSuite, bool? alwaysOn, String? hostFamily, String? srtpCrypto}) async {
    var payload = {
      "request": "rtp_forward",
      "room": roomId,
      "admin_key": adminKey,
      "group": group,
      "ssrc": ssrc,
      "codec": codec,
      "ptype": ptype,
      "host": host,
      "host_family": hostFamily,
      "port": port,
      "srtp_suite": srtpSuite,
      "srtp_crypto": srtpCrypto,
      "always_on": alwaysOn
    }..removeWhere((key, value) => value == null);
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return RtpForwarderCreated.fromJson(response.plugindata?.data);
  }

  /// Returns the list of participants currently joined to [roomId].
  Future<List<AudioBridgeParticipants>> listParticipants(dynamic roomId) async {
    var payload = {
      "request": "listparticipants",
      "room": roomId,
    };
    _handleRoomIdTypeDifference(payload);
    JanusEvent response = JanusEvent.fromJson(await this.send(data: payload));
    JanusError.throwErrorFromEvent(response);
    return (response.plugindata?.data['participants'] as List<dynamic>).map((e) => AudioBridgeParticipants.fromJson(e)).toList();
  }

  bool _onCreated = false;

  /// Sends a `leave` request after performing the base hangup cleanup.
  Future<void> hangup() async {
    await super.hangup();
    await this.send(data: {"request": "leave"});
  }

  /// Wires audio-bridge specific typed events after the plugin is attached.
  @override
  void onCreate() {
    super.onCreate();
    if (_onCreated) {
      return;
    }
    _onCreated = true;

    messages?.listen((event) {
      TypedEvent<JanusEvent> typedEvent = TypedEvent<JanusEvent>(event: JanusEvent.fromJson(event.event), jsep: event.jsep);
      var data = typedEvent.event.plugindata?.data;
      if (data == null) return;
      if (data["audiobridge"] == "joined") {
        typedEvent.event.plugindata?.data = AudioBridgeJoinedEvent.fromJson(data);
        _typedMessagesSink?.add(typedEvent);
      } else if (data["audiobridge"] == "event") {
        if (data["participants"] != null) {
          typedEvent.event.plugindata?.data = AudioBridgeNewParticipantsEvent.fromJson(data);
          _typedMessagesSink?.add(typedEvent);
        } else if (data["result"] == "ok") {
          typedEvent.event.plugindata?.data = AudioBridgeConfiguredEvent.fromJson(data);
          _typedMessagesSink?.add(typedEvent);
        } else if (data["leaving"] != null) {
          typedEvent.event.plugindata?.data = AudioBridgeLeavingEvent.fromJson(data);
          _typedMessagesSink?.add(typedEvent);
        } else if (data['error_code'] != null || data['result']?['code'] != null) {
          _typedMessagesSink?.addError(JanusError.fromMap(data));
        }
      } else if (data["audiobridge"] == "talking" || data["audiobridge"] == "stopped-talking") {
        typedEvent.event.plugindata?.data = AudioBridgeTalkingEvent.fromJson(data);
        _typedMessagesSink?.add(typedEvent);
      } else if (data["audiobridge"] == "destroyed") {
        typedEvent.event.plugindata?.data = AudioBridgeDestroyedEvent.fromJson(data);
        _typedMessagesSink?.add(typedEvent);
      } else if (data['audiobridge'] == 'event' && (data['error_code'] != null || data['result']?['code'] != null)) {
        _typedMessagesSink?.addError(JanusError.fromMap(data));
      }
    });
  }
}
